= ああ、やっぱり自動テストはやっていかねばと、心から思った理由


//flushright{
永田　敦@nagworld
//}

ソフトウェアテストの自動化は、今や開発に必須のアクティビティであることは、開発チームにおいて当たり前のこととなってきている。QAのカンファレンスの発表テーマのほとんどは、自動テストのことで占められている。


== サイボウズでの自動化の一事例：QAからの目線での長い前置き

最近、新しくフロントエンドチームが数チームできた。チームのプログラマの士気は高く、当然、自動テストにも積極的だった。そのチームには、QAメンバーも入っている。サイボウズのQAは、自らテストを行う。システムレベルのマニュアルテストがメインだが、E2Eの自動テストも実装する。すでに、POは、このフロントエンドチームについてのビジョンは作り共有している。QAはそれを踏まえて、今回、まず品質ポリシーを作り共有した。


QAは、テストだけでなく、仕様書もかかわるし、リリース・構成管理、不具合管理や、もろもろの品質の指針も出していく役割を持っている。すでにシフトレフトが浸透しているので、リファインメントやバックログのレビュー、スクラムイベントにも関わり、フィードバックを返している。仕様書は、プログラマと一緒にモブで作成・修正を行っている。そして、QAはしっかりとテスト仕様書を作って管理しているところが、大きな特徴だ。

品質ポリシーのメインは、テストのポリシーである。その中核は、自動テストの考え方だ。当然テストピラミッドがベースになるが、今回はフロントエンドなので、テスティング・トロフィーを採用することにした。インテグレーション・テストを厚くして行う戦略で、ピラミッドではなく、トロフィーの形になる。

テストスクリプトの実装は、プログラマが中心になる。QAも一部行う予定だが、インテグレーションテストが中心であり、リソースも限られている。こういう場合、テストスクリプトの設計と実装はプログラマにお任せ状態になることが多い。丸投げをするつもりはないが、QAにとって、インテグレーションテストは敷居が高いものだ
しかし、QAは、E2E,インテグレーション、ユニットテストに対しても、入り込んでいくことにした。

実は、以前に、あるPoCで、QAが作ったシステムテストレベルのテスト仕様書を使って、インテグレーションテストの設計をPGとモブでやったことがある。
それは無茶なと思う人もいるかもしれないが、試しにやってみることは、よい発見と学びが得られる。確かに、試験設計書はE2Eレベルの記述であり、そのままでは使えない。しかし、どんなテストをしたいかというテストの意思はプログラマと共有できる。じゃあ、インテグレーションテストでは、どこまで見ればよいかという議論ができた。その議論から、仕様書を書き直し、自動テストを実装してみた。素晴らしいことに、QAはそのあと、QAだけで、テスト仕様書の残りの部分を書き直すハッカソンをしていた。

今回も、この試みをして、テスト設計をプログラマとモブで行いながら進めていった。こうすることにより、多くのメリットが生まれた。


=== プログラマが安心する

プログラマが、自動テストを実装するとき、まず悩むのが、何を、どこまでテストすればよいのか、というWhatの部分である。しかし、QAとのテスト設計のモブによって、それが明確になる。ここまでやれば、品質的にここまでやれるということに確信、自信が持てるのだ。



=== テストの責務が明確になる

プログラマのほうから、コードの作りから、テストの責務のスコープがわかってくる。例えば、このバックログで実装しているコードに対して、テストの設計から見ると、テストの責務はここではなく、別なところ、例えばほかのコンポーネントやバックエンドの責務をテストしなければならないことがわかる。その場合は、そのテスト観点のテストはここではする必要はない。もっと、シンプルなインターフェースのテストを行えばよいことがわかるかもしれない。一方、QAは内部構造がわかり、適切なところで適切なテストを行うよう考えることができる。


=== QAが、すべての自動テストのレベルを俯瞰することができる
この活動は、今までシステムレベルでしか見られなかったテストを、インテグレーションレベル、そしてユニットテストレベルまで、見ることができるということになる。これは、すべてのテストレベルを網羅した、マスターテストプランを立てることともいえる。これにより、テストの漏れがなくなるとともに、テスティングトロフィーというテスト戦略を実現できる。

例えば、E2Eテストに複雑なストーリを入れてしまうと、flakyになるリスクがあるので、できるだけインテグレーションテストにもっていく、そのためにはどうしたらいかという具体的な議論ができる

・良かったこと

これは、まだチャレンジの域ではあるが、良い効果が表れている。プログラマとQAとのコミュニケーションがよりリッチになり、信頼関係がました。

プログラマは、仕様の検討にQAを呼び、QAとテスト設計を一緒に行う。

QAは、より多く、適切なフィードバックを返すようになり、リファインメントはもちろん、中期のプロダクトのミッションゴールを決める際にも、重要なスペシャリストとして参加している。

このように、自動テストのテスト設計にQAが入ることで、より、品質に確信・自信を持つことになってきている。もちろん、すべてを自動化するというのではない。そこは、前述のとおり、QAとプログラマが議論をし、トータルのコスト、時間を判断して、マニュアルテストが必要ならばそれを行う。

== ここからが本題：TDDをやろうとしたときの話

このようなとき、あるプログラマのリーダが、TDDをやっていこうと提案し、トライをしようとした。しかし、少し若いプログラマはトライをしようとして難色を示した。初めからテストを考えるのが難しい。実装がまだできていないのに、テストをどうやっていいか考えられない。なので、今は、実装してから、テストの実装をしていきたい。


実際、テストを実装しているモブに入り込み、観察することができた。その時は、テスト設計は、QAと済ませていたので、それに従ってテストを実装していた。ものすごく早くできるケースもあったが、なかなか難航する場合もあった。どこをどのようにモックすればよいか。そのモックはうまく作れるのか。テスト実行したときの結果が、うまくとれるか、それを自動で期待値と比較できるのか。そもそも、テストの責務が違うのではないか。しかも多様なライブラリを駆使しており、テスト環境が、機体のものになるかどうかも不安材料のようだった。

課題は多いのだが、一方でその苦しみの中から大いに学んでいることも分かった。
TDDは置いておいて、自動テストの実装は、コードの実装とテストコードの実装が、同時に行われている。同時というのは、両者の間を頻繁に行き来しながら行っているということである。

テスト実装をした際に、実行もすぐに行われ、すぐに結果が出てくる。その結果、つまりフィードバックで、コードを見たり、テストコードを見たりしている。コードを直せば、テストが不具合を見つけたこと、つまりテストが働いたということである。

実は、これが、開発者に対するテストの最速のフィードバックである。そして、そのバグを直して、同じテストでパスすることが、最もアジャイルな品質改善の瞬間なのだ。

もちろん、そのあとで、CIで回帰テスト的に自動テストを流すのは重要である。でも、それよりも品質に良いと感じるは、このアジャイルな自動テストのフィードバックである。この自動テストは、このコードが完成するまで何回も実行される。もし、手動でテストしていたら大変な負荷なばかりではない、テストの実行を間違えてしまうかもしれない。この自動テストのフィードバックしている瞬間が、自動テストが一番効果的な場面かもしれない。もちろん、テストコードもコードだから、こちらを直すこともあるだろう。でも、それはこの一番効率的な場面を作り出すための必要なコストだ。

TDDは、このステップをバックログよりもさらに細かく進めていく。ある意味で、非常に探索的なコード開発で、特に複雑なバックログに対しては効果的だ。初めから一発で作れないような、問題を解くために、一歩一歩テストで確かめて進む。ともすると、今書いたコードを作り直さないと、次のテストは見た際かもしれない。でも、それは、正しいコードを作るためのコストなのだ。

そして、一つパスしたら、次の段階に行くために、コードを整える、つまり保守性を高めながら、次のチャレンジに臨むのだ。逆を言えば、単純なものならば、TDDはしなくてもいいといえるかもしれない。そう考えれば、TDDも決して難しくはない

ただ、テスト実装のスキルは鍛えなければならない。テストを考えるのが難しいのではなく、そのテストの実装が慣れていないため、複雑に感じ、見通しが立たないことが一つの壁になっているように思える。ならば、まずは、ある程度、テスト実装のスキルをつけることをしてからでもいいかもしれない。テスト実装に慣れてくれば、コード実装と同時にテスト実装をすることも楽になる。もともとコードを書くことが好きだから、テストコードを書くことは苦ではないし、すぐにフィードバックが返り、達成感も生まれる。この時点で、どのようにテストを実装すればよいかはわかってきたが、次には、テスト設計、つまり何をテストするか課題になる。ここの場面で、QAとのコラボをするようにした。QAがテスト設計をサポートすることで、より抜け漏れのないテストを実装できるようになった。これを続けていけば、開発は、次第にテストを先に考えることができるようになる、つまりTDDに変わっていく期待を持っている。

・学び：自動テストのおいしいところは、最速フィードバック

この、自動テストのチャレンジを観察してみての一番の学びは、自動テストの一番おいしいところは、フィードバックが最速だということだ。

もし、自動化を行わず、そのテストをテスターに任せて、そのフィードバックを待つ場合、下手をすれば、数スプリント後に、不具合のバックログ返ってくるかもしれない。そうなった場合、もう次のバックログに手を付けているし、もしかしたら人の作った不具合を直すことになる。いずれにしても、その不具合を直すためには、自動テストよりも圧倒的に時間がかかるだろうし、コードが劣化するリスクも生まれてくるかもしれない。実際、後でテストをする、というチームは、不具合のバックログが多く発生している。あるデータでは全体の完成したバックログの２割を超える場合もある。

もちろん、自動テストの実装には時間がかかる。前述のとおり、テスト実装になれていない場合には、早いフィードバックができない。しかしテスト実装はコード実装と実質は同じと考えれば、じきに慣れる。テスト設計に不安があれば、QAがサポートする。学習するにつれて、自動テストの実装は早くなり、この最速のフィードバックを享受できる。


== まとめ

テストを自動化することは、その行為がプログラマに最短のフィードバックをしていることに気づいた。これは、テスティングにおいて、最もアジャイルな活動になる。そこが重要なんだなと、この体験で、恥ずかしながら、やっと心から要性を実感した、というのが共有したいことでした。

　

//embed{
    \begin{minipage}{.1\linewidth}
        \centering
        \includegraphics[width=.75\linewidth]{images/nagata.png}
    \end{minipage}
    \begin{minipage}{.89\linewidth}
        nagworld @nagworld  https://twitter.com/nagworld
        \end{minipage}
    \hspace{1ex}
//}


アジャイルの品質って何だろう、と、ずーっと探索しているおじさんです。今はサイボウズでアジャイル・クオリティというチームで探索を続けています。

